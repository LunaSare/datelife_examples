---
title: "DateLife Workflows"
author: "Luna L. Sanchez Reyes"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
header-includes:
- \usepackage{booktabs}
- \usepackage{makecell}
- \usepackage{multirow}
- \usepackage{longtable}
- \usepackage{caption}
- \usepackage{array}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{xcolor}
geometry: "left=2.5cm,right=2.5cm,top=2cm,bottom=2cm"
vignette: >
  %\VignetteIndexEntry{DateLife Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include = FALSE}
# - \usepackage{tabu}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
my_table_format <- function(tt){
  res <- format.data.frame(tt, digits = 4, nsmall = 4, justify = "none")
  return(res)
}
library(microbenchmark)
loadd(taxon)
loadd(tax_dq)
loadd(tax_dr)
loadd(tax_summ)
loadd(tax_phyloall)
phyloall_success <- ape::is.ultrametric(tax_phyloall, option = 2)
loadd(tax_median_phylo)
loadd(tax_sdm_phylo)
loadd(tax_sdm_matrix)
loadd(tax_datedotol)
loadd(tax_allcal_datedotol)
loadd(tax_otol)
loadd(tax_treefromtax)
loadd(tax_phyloall)
loadd(tax_eachcal_datedotol)
loadd(tax_crossval)
loadd(tax_phycluster)
loadd(sdm2phylo_bladj)
# loadd(tax_crossval2)
loadd(tax_summary)
fig_lttplot_phyloall <- "Fig. 1"
fig_lttplot_sdm <- "Fig. 3"
fig_lttplot_median <- "Fig. 4"
figcap2 <- paste(taxon, "Species Tree from Taxonomy. This tree was obtained with `tree_from_taxonomy()` function.")
table_chronograms <- "Table 1"
table_crossval <- "Table 2"
```
\raggedright

# Taxon `r taxon`

## I. Query source data
There are `r length(tax_dq$cleaned_names)` species in the Open Tree of Life Taxonomy for the taxon `r taxon`.
Information on time of divergence is available for
```{r echo = FALSE, results = 'asis'}
tt <- nrow(tax_median_phylo$taxon_distribution)
if(tt == length(tax_dq$cleaned_names)){
  cat("all")
} else {
  cat(nrow(tax_median_phylo$taxon_distribution))
}
```
of these species across `r length(tax_dr)` published and peer-reviewed chronograms.
Original study citations as well as proportion of `r taxon` species found across those source
chronograms is shown in `r table_chronograms`.

```{r echo = FALSE, warning=FALSE, message = FALSE, results = 'asis'}
if(all(phyloall_success)){
  cat("All source chronograms are fully ultrametric.\n")
} else {
  cat("Not all source chronograms are fully ultrametric. This cant't be right, CHECK THIS!!\n")
}
# Error producing PDF.
# ! Undefined control sequence.
# l.124 \toprule
# this occurs when the needed latex package is not specified in the yaml ^^
table_caption <- paste(taxon, "source chronogram studies information.")
make_table0(tax_dr, tax_summ, tax_dq, table_caption)
```

Source chronograms maximum age range from `r round(min(tax_summary$mrca), digits = 3)` to
`r round(max(tax_summary$mrca), digits = 3)` million years ago (MYA).
As a means for comparison, lineage through time plots of all source chronograms
available in data base are shown in `r fig_lttplot_phyloall`


```{r LTTplot-phyloall, echo = F, results = 'asis', fig.cap= ""}
figcap_lttplot_phyloall <- paste0("Lineage through time (LTT) plots of source chronograms available in data base
  for species in the ", taxon, ". Numbers correspond to original studies in ", table_chronograms,
  ". Arrows indicate maximum age of chronograms.")

lttplot_phyloall <- paste0("\n![", figcap_lttplot_phyloall, "](plots/", taxon, "_LTTplot_phyloall.pdf)\n")
cat(lttplot_phyloall)
```


\newpage


## II. Summarize results.

LTT plots are a nice way to visually compare several trees. But what if you want
to summarize all that information into a single chronogram?
What to do when source chronograms have different species content?
First identify the degree of species overlap among your source chornograms. If each
source chronogram has its own set of species, it will not be possible to combine
them into a single summary chronogram. To identify the grove with the most source
chronograms that have at least two overlapping taxa, we followed AnÃ© et al. 2016.
Once you have identified a suitable grove, you can go on to summarize
it, by translating the source chronograms into patristic distance matrices and
then averaging them into a single summary matrix; yes, this first step is _that_
straightforward. You can average the source matrices by simply using the mean or
median distances, or you can use more complicated approaches that involve transforming
the original distance matrices --such as SDM-- by minimizing
the distances across source matrices.
Once you have a summary matrix, it is suggested that a distance-based clustering
algorithm can be used to reconstruct the tree. Algorithms such as Neighbour Joining (NJ) and UPGMA are
fast and work well when there are no missing values in the matrices. However, summary
matrices coming from source chronograms usually have several NAs and missing rows.
This data set for example has NUMBER.
When this happens, even variants of NJ and UPGMA algorithms available that are designed to deal with missing taxa do
not work well, as shown in the next section. Other methods designed to deal with missing data are BIONJ*,
MVR*, and the triangle method, but we have not tried them yet.


### II.A. Diagnosing clustering issues.

We identified some issues with chronograms coming from SDM and Median summary matrices.
First, clustering algorithms used to go from a summary distance matrix to
a tree return trees that are too old (generally with UPGMA algorithms) or non-ultrametric
(generally with NJ algorithms). In most studied cases, UPGMA returns
fully ultrametric trees but with very old ages (we had to multiply the matrix by
0.25 to get ages approximate to source chronograms ages, however this is a number
chosen at random, it was just the number that worked well). NJ returned reasonable
ages, but trees are way non ultrametric, as you can see in `r fig_lttplot_sdm`
and `r fig_lttplot_median`.

```{r eval = TRUE, echo = F, results = 'asis'}
negs_list <- list(SDM = which(tax_sdm_matrix < 0),
                 Median = which(tax_median_matrix < 0))
tax_summ_matrix <- list(tax_sdm_matrix, tax_median_matrix)
figcap_lttplot_summ <- rep(list(""), 2)
for (i in seq_along(negs_list)){
  if(length(negs_list[[i]])>0){
    xx <- rownames(tax_summ_matrix[[i]])[ceiling(negs_list[[i]]/nrow(tax_summ_matrix[[i]]))]
    figcapextra <- "As you can note, dashed lines and solid lines from trees coming out from both types of clustering algorithms implemented are mostly overlapping. This means that removing negative values does not change results from clustering algorithms much."
    cat(paste0("This taxon's ", names(negs_list)[i], " matrix has some negative values in the following taxa: *", paste(xx, collapse = "*, *"), "*. "))
  } else {
    figcapextra <- ""
    cat(paste("This taxon's",  names(negs_list)[i], "matrix has NO negative values."))
  }
  figcap_lttplot_summ[[i]] <- paste(taxon, "lineage through time (LTT) plots from source chronograms and", names(negs_list)[i], "summary matrix converted to phylo with different methods (NJ and UPGMA).", figcapextra, "Clustering algorithms used often are returning non-ultrametric trees or with maximum ages that are just off (too old or too young). So we developped an alternative algorithm in `datelife` to go from a summary matrix to a fully ultrametric tree.")
}

```

```{r LTTplot-median, echo = F, results = 'asis', fig.cap= ""}
lttplot_median <- paste0("\n![", figcap_lttplot_summ[[2]], "](plots/", taxon, "_LTTplot_Median.pdf)\n")
cat(lttplot_median)
```


```{r LTTplot-sdm, echo = F, results = 'asis', fig.cap= ""}
lttplot_sdm <- paste0("\n![", figcap_lttplot_summ[[1]], "](plots/", taxon, "_LTTplot_SDM.pdf)\n")
cat(lttplot_sdm)
```

### II.B. Age distributions form Median and SDM summary trees.

Comparison of summary chronograms reconstructed with min and max ages.

```{r LTTplot-median-summtrees, echo = F, results = 'asis', fig.cap= ""}
for(i in 1:2){
  figcap_lttplot_summ[[i]] <- paste(taxon, "lineage through time (LTT) plots from source chronograms and", names(negs_list)[i], "summary matrix converted to phylo with `datelife` algorithm.")
}

lttplot_median <- paste0("\n![", figcap_lttplot_summ[[2]], "](plots/", taxon, "_LTTplot_summtrees_Median.pdf)\n")
cat(lttplot_median)
```


```{r LTTplot-sdmsummtrees, echo = F, results = 'asis', fig.cap= ""}
lttplot_sdm <- paste0("\n![", figcap_lttplot_summ[[1]], "](plots/", taxon, "_LTTplot_summtrees_SDM.pdf)\n")
cat(lttplot_sdm)
```


\newpage


## III. Create new data


As an example, we're gonna date the Open Tree Synthetic tree (mainly because the taxonomic tree is usually less well resolved.)
```{r echo = FALSE}
txtA <- toupper("Something is missing.")
if(!inherits(tax_allcal_datedotol, "list")){
  txtA <- paste(taxon, "and no tree could be constructed.")
} else {
    if(is.null(tax_allcal_datedotol$phy)){
      txtA <- paste(taxon, "and they do not agree, so no tree could be constructed.")
    } else {
      if(all(is.na(tax_allcal_datedotol$phy$edge.length))){
        txtA <- paste(taxon, "and a tree was constructed, but all branch lengths are NA.")
      } else {
          txtA <- paste(taxon, "and a tree with", ape::Ntip(tax_allcal_datedotol$phy), "tips,",
                        round(tax_allcal_datedotol$phy$Nnode/ape::Ntip(tax_allcal_datedotol$phy)*100),
                        "% resolved nodes and a MRCA of",
                        round(max(ape::branching.times(tax_allcal_datedotol$phy))),"was constructed.")
      }
    }
}
```

Now, let's say you like the Open Tree of Life Taxonomy and you want to stick to that tree. Dates from available studies were tested over the Open Tree of Life Synthetic tree of `r txtA`
We also tried  each source chronogram independently, with the Dated OToL and with each other, as a form of cross validation in `r table_crossval`. This is not working perfectly yet, but we are developping new ways to use all calibrations efficiently.

\newpage
```{r echo = FALSE}
table_cap <- "Was it successful to use each source chronogram independently as calibration (CalibN) against the Dated Open Tree of Life (dOToL) and each other (ChronoN)?"
table2 <- cbind(tax_eachcal_datedotol, do.call(cbind, tax_crossval))
dimnames(table2) <- list(paste0("Calibrations", seq(tax_crossval)), c("dOToL", paste0("Chrono", seq(tax_crossval))))
if(ncol(table2) < 7) fs <- 10
if(ncol(table2) == 7 | ncol(table2) == 8) fs <- 9
if(ncol(table2) >= 9) fs <- 7
if(ncol(table2) > 10) {
  table2ori <- table2
  table2[table2 == TRUE] <- "yes" # "&#x2611;"  # :tick:
  table2[table2 == "FALSE"] <- "no"  # "&#x2612;"
  dimnames(table2) <- list(paste0("Calib", seq(tax_crossval)),
                           c("dOToL", paste0("Chr", seq(tax_crossval))))
}
tt <- knitr::kable(table2, caption = table_cap, row.names = TRUE, format = "latex", booktabs = TRUE)
kableExtra::kable_styling(kable_input = tt, position = "left", font_size = fs)
```
\newpage
## III. Simulate data
An alternative to generate a dated tree from a set of taxa is to take the available information and simulate into it the missing data.
We will take the median and sdm summary chronograms to date the Synthetic tree of Life:
```{r LTTplot-sims, echo = F, results = 'asis', fig.cap= ""}
lttplot <- paste0("\n![", figcap_lttplot_sdm, "](plots/", taxon, "_LTTplot_sdm.pdf)\n")
cat(lttplot)
```

\newpage

## Appendix
```{r echo = FALSE, results = 'asis'}
absent <- levels(tax_median_phylo$absent_taxa$taxon)
if(!"None" %in% absent){
  cat("The following species were completely absent from the chronogram data base: ", paste0("*", levels(tax_median_phylo$absent_taxa$taxon), collapse = "*, *", "*"))
}
```
```{r myfile-1-plot, echo = F, results = 'asis', fig.cap= ""}
# knitr::include_graphics(paste0("docs/datedotol_", taxon, ".pdf"))
figcap <- paste(taxon, "Species Dated Open Tree of Life Induced Subtree. This chronogram was obtained with `get_dated_otol_induced_subtree()` function.")

if(!inherits(tax_datedotol, "phylo")){
  plot1 <- paste0("Dated induced subtree could not be obtained for the ", taxon, ".\n")
} else {
  plot1 <- paste0("\n![", figcap, "](plots/", taxon, "_datedotol.pdf)\n")
}
cat(plot1)
```
